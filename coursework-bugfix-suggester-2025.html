<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Tom's Articles</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=JetBrains+Mono&display=swap">
    <link rel="stylesheet" href="./css/default.css">
    <link rel="icon" type="image/png" href="./favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="./favicon/favicon.svg" />
    <link rel="shortcut icon" href="./favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="./favicon/apple-touch-icon.png" />
    <link rel="manifest" href="./favicon/site.webmanifest" />
</head>
<body>
    <div class="header-buttons">
        <div class="home">
            <a href=".">Все статьи</a>
        </div>
        <div class="tg">
            <a href="https://t.me/tom_suworof_channel">Телеграм-канал</a>
        </div>
    </div>
    <div class="article-root col-md-8 offset-md-2"><h1>Использование больших языковых моделей при поиске и исправлении неисправностей в программном обеспечении</h1>
<div class="article-publication-date">
    <time datetime="2025-06-16 10:00">16.06.2025 10:00</time>
</div>
<h1>ВВЕДЕНИЕ</h1>
<p>Компании, которые занимаются разработкой программного обеспечения, обычно разделяют разработчиков на две большие группы: на тех, кто создаёт новые продукты, и тех, кто занимается поддержкой созданных ранее решений. Первую группу называют отделом научно-исследовательских и опытно-конструкторских работ, НИОКР (англ. R&amp;D — research and development). Вторую группу — инженеры поддержки (англ. Development Support <a href="#1">[1]</a>). Первая группа работает на поиск новых клиентов, вторая — на удержание клиентов. Первая — на будущее, вторая — на прошлое и настоящее. Но есть то, что объединяет эти две группы: поиск и исправление ошибок и неисправностей в программном коде.</p>
<p>В отделе НИОКР работа с ошибками — часть итерации над поиском оптимального решения задачи. Создание комплексных систем, сложных алгоритмов, взаимосвязанных компонентов — всё это сопровождается ошибками, которые не сразу могут быть обнаружены.</p>
<p>В отделе поддержки, как правило, ошибки обнаруживают клиенты, пользователи программного обеспечения. Эти ошибки не были обнаружены заранее, на этапах разработки и тестирования.</p>
<p>В обоих случаях — когда разработчики замечают ошибки на этапе решения задачи и когда пользователи обращаются с найденной проблемой — необходимо оперативно их устранить, потому что наличие ошибки равно потере средств компании-разработчика. В первом случае — потому что разработка останавливается из-за необходимости устранения ошибки; во втором — потому что компания может быть вынуждена покрывать убытки клиента, которые принесла эта ошибка.</p>
<p>Данная работа посвящена поиску решения, способного ускорить обнаружение и исправление ошибок в программном обеспечении. В работе будут представлены методы обнаружения и исправления ошибок на основе статического и динамического анализа — которые далее будут обозначаться как «классические» методы — и на основе больших языковых моделей, БЯМ (англ. LLM — large language model).</p>
<p><strong>Цель данной работы</strong>: создание алгоритма для оптимального совмещения возможностей различных методов для поиска и исправления неисправностей в программном обеспечении.</p>
<p><strong>Задачи работы</strong>: 1. Составление перечня классических методов и инструментов поиска неисправностей: статический и динамический анализ; 2. Составление перечня классических методов и инструментов исправления неисправностей; 3. Исследование принципов работы современных БЯМ; 4. Составление перечня инструментов поиска неисправностей на основе БЯМ; 5. Сравнительный анализ классических методов и методов на основе БЯМ в задаче с поиском неисправностей в ПО; 6. Составление перечня инструментов исправления неисправностей на основе БЯМ; 7. Сравнительный анализ классических методов и методов на основе БЯМ в задаче с исправлением неисправностей в ПО; 8. Создание решения с совместным использованием классических методов и методов на основе БЯМ.</p>
<h1>1. КЛАССИЧЕСКИЕ МЕТОДЫ ПОИСКА И ИСПРАВЛЕНИЯ НЕИСПРАВНОСТЕЙ В ПРОГРАММНОМ ОБЕСПЕЧЕНИИ</h1>
<p>В данной главе будут рассмотрены методы и инструменты поиска неисправностей на основе статического и динамического анализа — далее они будут называться «классическими» — и методы и инструменты исправления неисправностей.</p>
<h2>1.1. Классические методы поиска неисправностей в программном обеспечении</h2>
<h3>1.1.1. Статический анализ</h3>
<p>Инструменты статического анализа не запускают программу, а работают с её исходным кодом или с его представлением, которое было получено после его обработки (например, после компиляции в байт-код в случае с Java). Статические анализаторы проверяют паттерны проектирования, некорректное использование языка и библиотек, сообщая о проблемах пользователю во время сборки программы или отображая ошибки в редакторах и интегрированных средах разработки <a href="#2">[2]</a>.</p>
<p>Важно отметить, что ошибки компилятора не относятся к ошибкам, найденным в ходе статического анализа. Инструменты статического анализа — отдельные инструменты, обособленные от компиляторов.</p>
<p>Инструменты статического анализа принято называть «линтерами» (англ. linters) в честь первого инструмента — утилиты lint <a href="#3">[3]</a>, созданной Стивеном Джонсоном для проверки кода на языке C. Утилита проверяла выражения, которые не могут быть перенесены между платформами, участки с неиспользуемым кодом, ошибки приведения типов.</p>
<p>Широкое распространение линтеры получили в языках программирования с динамической типизацией: JavaScript и Python. Наиболее популярные инструменты для этих языков — ESLint <a href="#4">[4]</a> и Pylint <a href="#5">[5]</a>. Существуют линтеры и для языков со статической типизацией: для C++ есть Clang-Tidy <a href="#6">[6]</a>, для Java — PMD <a href="#7">[7]</a>, SpotBugs <a href="#8">[8]</a>. Также существуют инструменты статического анализа, которые умеют работать с несколькими языками программирования: например, PVS-Studio <a href="#9">[9]</a>, SonarCube <a href="#10">[10]</a>, Infer <a href="#11">[11]</a><a href="#12">[12]</a>.</p>
<p>Отдельно стоит упомянуть статический анализатор CodeQL от GitHub <a href="#13">[13]</a>. Данный инструмент состоит из двух частей: статического анализатора и языка запросов к исходному коду QL <a href="#14">[14]</a>. Это позволяет определить путь от ошибки в коде до места в пользовательском интерфейсе, которое приведёт к этой ошибке.</p>
<h3>1.1.2. Динамический анализ</h3>
<p>Динамический анализ как подход изучения ПО предполагает запуск программы с изучением её работы и влияния на окружение. Основа анализа — допущение, что программа представляет собой набор доступных снаружи входов и выходов и недоступных, расположенных внутри, алгоритмов. Изменяя входные данные, методы динамического анализа проверяют выходные данные и влияние на окружающую среду.</p>
<p>Тестирование <a href="#15">[15]</a> — самый распространенный метод динамического анализа. Данный метод заключается в создании обёртки вокруг программы (англ. test suite), который проверяет её работу. Тестирование нужно для проверки отдельных методов программы, компонентов и комплексной работы программы. Проверка производится на заранее известных данных: при создании теста описывают входные данные, ожидаемые выходные данные и проверяют фактические выходные данные — результат работы алгоритма. Существуют инструменты тестирования, которые позволяют проверять промежуточные вызовы, чтобы удостовериться в правильной последовательности операций.</p>
<p>Чтобы избавиться от предопределённости в тестировании и исследовать возможные нетривиальные случаи (так называемые “edge cases” или “corner cases” — пограничные ситуации), применяется «фаззинг». «Фаззинг» (англ. fuzzing, fuzz testing) — вид тестирования, при котором на вход в тестируемую систему подаётся случайный набор данных <a href="#16">[16]</a>. Данные могут быть как по-настоящему случайными, не имеющими нужного для входа формата — фаззинг такого типа называется мутационным, — так и форматированными, но с элементами случайности (например, JSON с определёнными полями, но случайными значениями в них) — это порождающий фаззинг <a href="#17">[17]</a>.</p>
<p>Инструменты тестирования представляют собой целые фреймворки, потому что позволяют проверять программное обеспечение сразу на нескольких уровнях и заставляют разработчиков писать исходный код в таком стиле, чтобы его можно было «покрыть тестами» — то есть для каждого входа и выхода создать алгоритм их проверки. Среди фреймворков для тестирования стоит выделить JUnit <a href="#18">[18]</a> для Java,  GTest <a href="#19">[19]</a> для C++, PyTest <a href="#20">[20]</a> для Python. Для фаззинг-тестирования — JBroFuzz <a href="#21">[21]</a> от OWASP, позволяющий проверять веб-приложения.</p>
<p>Фреймворки для тестирования устроены по одному принципу: есть ввод, есть исследуемый алгоритм, есть желаемый вывод, есть фактический вывод, который должен совпасть с ожидаемым. Такой подход используется в большинстве языков, когда нужно проверять именно алгоритм. Но также есть подходы и инструменты, которые позволяют проверять результат всей программы.</p>
<p>Тестированием всей программы является анализ производительности программы: так же, как при обычном тестировании, существует вход — входные данные, окружение, — алгоритм — исследуемая программа, — ожидаемый выход — ожидаемые потребление ресурсов системы, — фактический вывод — фактические потребление ресурсов. Инструменты для анализа производительности: JMeter <a href="#22">[22]</a> <a href="#23">[23]</a> и VisualVM <a href="#24">[24]</a> для Java, gprof <a href="#25">[25]</a>, perf <a href="#26">[26]</a>, Valgrind <a href="#27">[27]</a> для C++.</p>
<p>Если программа предоставляет интерфейс для взаимодействия, то он также может быть протестирован. Консольный интерфейс можно протестировать с использованием Judo <a href="#28">[28]</a>, Web-API — с использованием тестов в Postman <a href="#29">[29]</a>, графический интерфейс — Selenium <a href="#30">[30]</a>, Puppeteer <a href="#31">[31]</a>.</p>
<h2>1.2. Классические методы исправления неисправностей в программном обеспечении</h2>
<p>Выше были приведены инструменты, упрощающие поиск неисправностей в программном коде. Эти инструменты выводят список проблем, которые есть в программном коде, или указывают на места, где может находиться ошибка: ошибка логики, неправильное использование алгоритма. Со всеми этими проблемами предстоит разобраться разработчикам, если они хотят улучшить продукт. В помощь им существуют инструменты, исправляющие исходный код — так называемые Автоматические инструменты Исправления Программ (англ. Automatic Program Repair tool, APR tool) <a href="#32">[32]</a><a href="#33">[33]</a>. В этой главе будет рассказано об этих инструментах, а также будет приведена их классификация по методу работы.</p>
<p>Все описанные далее инструменты работают на основе тестов (англ. Test Suite based Program Repair): на вход инструментам подаётся программа и тесты, которые она должна проходить (подробнее об этом говорилось в разделе о динамическом анализе). Тесты здесь выступают как спецификация работы программы за неимением формального описания программы <a href="#34">[34]</a>. Это нужно, чтобы понять, до какой степени изменять программу, какое у неё должно быть задуманное поведение. В исследованной литературе такой подход называют «генерируй и проверяй» (англ. Generate-and-Validate). Все инструменты такого метода реализуют один и тот же алгоритм: локализация ошибки, создание исправления, проверка исправления. В результате работы инструменты создают так называемые «патчи», (англ. patch — заплата), применимость которых оценивается разработчиком.</p>
<h3>1.2.1. Исправления на основе эвристик</h3>
<p>Одним из ранних инструментов автоматического исправления программ является GenProg <a href="#35">[35]</a>. Он использует генетическое программирование для поиска исправлений дефектов. Итоговое исправление получается путём пошагового применения наиболее подходящих промежуточных исправлений поменьше <a href="#36">[36]</a>. Инструмент создавался для языка С, но также есть копия инструмента для языка Java — jGenProg <a href="#37">[37]</a>. Последователями инструмента являются: RSRepair <a href="#38">[38]</a> —  используется не генетическое программирование, а случайный поиск для поиска исправлений <a href="#39">[39]</a>; ARJA <a href="#40">[40]</a> — предоставляют улучшения в области поиска исправлений, предлагает многоцелевую оптимизацию, работает с языком Java <a href="#41">[41]</a>.</p>
<h3>1.2.2. Исправления на основе модели</h3>
<p>К этой категории относятся инструменты, которые в процессе работы создают промежуточное представление, которым оперируют при создании исправления. В разной литературе эту категорию называют по-разному: - «на основе синтеза» (англ. synthesis-based) — по итогу работы программа обратно синтезируется из модели; - «на основе семантики» (англ. semantics-based) — инструменты работают не с кодом, а со «значением» конструкций; - «на основе ограничений» (англ. constraint-based) — инструменты работают с конечным множеством решений и применяют соответствующие математические алгоритмы для создания исправлений.</p>
<p>SemFix <a href="#42">[42]</a> (Semantic-based Program Fixing) — инструмент для языка C, использующий динамическую символьную интерпретацию (англ. dynamic symbolic execution, DSE) для создания исправлений <a href="#43">[43]</a>. SemFix сканирует программу, находит в ней «подозрительные» места (подозрительные в контексте исследуемой проблемы конкретного теста), «решает» подозрительные места с учётом других тестов и переводит решение в исправление на языке исходного кода. Решение здесь происходит как раз за счёт DSE — при таком подходе программа с ветвлениями и переменными превращается в дерево состояний с переменными и переходами по ветвям с условиями, которое может быть представлено математически. Как признаются авторы, инструмент имеет свои ограничения, связанные с DSE: он показывает плохую производительность на сложных проектах с множеством связей.</p>
<p>Nopol <a href="#44">[44]</a> — инструмент для языка Java, специализирующийся на исправлении if-условий. В работе Nopol использует Задачу выполнимости формул в теориях (англ. SMT — Satisfiability Modulo Theory) <a href="#45">[45]</a>. Инструмент находит проблемное if-условие, из-за которого не проходит тест, собирает влияющие на это выражение переменные, переводит их в математическое представление в терминах SMT, решает и переводит решение обратно в исходный код.</p>
<h3>1.2.2. Исправления на основе шаблонов</h3>
<p>Инструменты для исправления программ на основе шаблонов (англ. Template-based repair approaches) используют заранее собранные ошибки и их исправления как базу знаний для новых исправлений.</p>
<p>PAR <a href="#46">[46]</a> (Pattern-based Automatic program Repair) — инструмент для создания исправлений на основе заранее отобранных исправлений, созданных разработчиками при решении типовых проблем <a href="#47">[47]</a>. Авторы инструмента проанализировали свыше 60 000 исправлений, созданных разработчиками и создали на их основе 10 шаблонов, которые представляют собой скрипты исправления кода. Для оценки инструмента использовались 119 ошибок из больших и популярных проектов на Java — Apache Log4J, Rhino, AspectJ — и оценки 253 разработчиков. Инструмент представляет собой скопление опыта разработчиков при решении проблем (по крайней мере, тех, которые были найдены в исследуемых проектах). Однако в этом его слабость — он предлагает только те исправления, которые ему известны и только такие исправления, какие бы написали разработчики-люди <a href="#48">[48]</a>.</p>
<p>AVATAR <a href="#49">[49]</a> — инструмент для создания исправлений на основе заранее отобранных исправлений. Отличительной чертой инструмента является упор на ошибки, найденные статическими анализаторами (в оригинальной статье говорится про FindBugs, SpotBugs, Infer, ErrorProne) <a href="#50">[50]</a>, так как большинство из них пересекается с ошибками, которые могут быть найдены при методах, основанных на тестировании.</p>
<h3>1.2.3. Исправления на основе машинного обучения</h3>
<p>Инструменты из этой категории используют методы классического машинного обучения (англ. machine learning) и глубокого обучения (англ. deep learning) для нахождения и исправления ошибок. В данной работе к этой категории будут относиться инструменты без использования архитектуры трансформеров и больших языковых моделей — о них будет рассказано в следующей главе.</p>
<p>FixMiner <a href="#51">[51]</a> — инструмент, использующий представление кода в виде AST (Abstract Syntax Tree, Абстрактное Синтаксическое Дерево) для создания исправлений. База исправлений была собрана на основе проблем в облачном сервисе контроля версий GitHub в формате GNU diff (текстовый формат отображения изменения в коде), которые были переведены в формат, пригодный для использования в AST, и распределены по кластерам <a href="#52">[52]</a>.</p>
<p>Liana (Learn It AgaiN for APR) — инструмент для исправления ошибок для языка Java, обучающийся на своих исправлениях, чтобы на каждой следующей итерации улучшать их <a href="#53">[53]</a>. Исправления анализируются и в итоге выбирается лучшее, которое может содержать черты других исправлений, за счёт обучения ранжированию (англ. learning to rank).</p>
<p>SynFix — инструмент для языка Python, использующий RNN (Recurrent Neural Network, Рекуррентная Нейронная Сеть) для исправления синтаксических ошибок, обученную на ошибках студентов онлайн-курсов, и методы на основе ограничений для обеспечения функциональной корректности алгоритма <a href="#54">[54]</a>.</p>
<h3>1.2.4. Бенчмарки и сравнение</h3>
<p>Инструменты автоматического исправления программ могут значительно упростить часть работы разработчиков, касающуюся исправления ошибок. Но только часть этой работы. Исследования на основе различных бенчмарков показывают <a href="#55">[55]</a><a href="#56">[56]</a>, что не все инструменты могут исправить даже половину ошибок. Рабочими (с точностью выше 75%) являются только инструменты на основе машинного обучения. Связано это с тем, что инструменты создаются на основе существующих бенчмарков и страдают от переобучения <a href="#57">[57]</a><a href="#58">[58]</a>: инструменты выдают правдоподобные результаты, которые позволяют пройти тесты, но не результаты, которые были бы корректны в контексте всей программы. Более того, улучшение тестового покрытия не всегда приводит к лучшей работе программ для исправления ошибок — инструменты могут не выдавать никакое исправление в принципе.</p>
<h1>2. МЕТОДЫ ПОИСКА И ИСПРАВЛЕНИЯ НЕИСПРАВНОСТЕЙ В ПРОГРАММНОМ ОБЕСПЕЧЕНИИ С ИСПОЛЬЗОВАНИЕМ БОЛЬШИХ ЯЗЫКОВЫХ МОДЕЛЕЙ</h1>
<p>В этой главе будет проведён анализ методов и инструментов для поиска и исправления неисправностей на основе больших языковых моделей. Однако, прежде чем приступить к изучению методов и инструментов, необходимо изучить, как устроены большие языковые модели, по каким принципам они работают.</p>
<h2>2.1. Устройство больших языковых моделей</h2>
<p>Языковая модель — это нейросетевая модель для работы с текстом. Задача такой модели — генерировать текст или, более формально, выводить следующий текстовый токен (часть слова) на основе предыдущих <a href="#59">[59]</a>. Языковые модели используются для генерации текста, распознавания речи, перевода и других задач, связанных с текстом.</p>
<p>Большая языковая модель — подвид языковой модели, характеризующимся использованием архитектуры трансформеров, генеративного пред-обучения, до-обучения и большим количеством параметров <a href="#60">[60]</a>.</p>
<p>Архитектура трансформеров была представлена Google <a href="#61">[61]</a> и ввела механизм внимания, позволяющий модели учитывать определённые места во входных данных больше остальных за счёт перераспределения весов. Это позволило обучать модели быстрее, чем RNN.</p>
<p>Скачок в развитии БЯМ произошёл с приходом генеративного пред-обучения. Этот подход позволил моделям обучаться без использования специально размеченных текстов, что значительно расширило область применения моделей. В статье от OpenAI <a href="#62">[62]</a> сказано, что тренировка модели GPT-1 проходила в 2 этапа: 1. (пред-)обучение на неразмеченном тексте; 2. точечное дополнительное обучение модели под конкретную задачу — генерацию текста.</p>
<p>Обучение на неразмеченном тексте происходило на большом наборе данных BookCorpus). Исследователи OpenAI отмечают: так как задача модели — предсказание следующего слова на основе предыдущих, — то большой корпус текста, написанного людьми, с длинными последовательными выражениями содержит достаточно слов, идущих друг за других, чтобы определить закономерности в языке.</p>
<p>Дальнейшим развитием для БЯМ стало наращивание данных, используемых для пред-обучения, параметров модели, которые «хранят закономерности языка» (модель GPT-2 имеет 1.5 млрд параметров против 117 млн у GPT-1 <a href="#63">[63]</a>), до-обучении с использованием наборов данных с диалогами (GPT-3 <a href="#64">[64]</a>), использование «промптов» (англ. prompt, подсказка, которая даётся модели для дальнейшей генерации, ChatGPT), пошаговое решение (начавшееся как практика в промптах <a href="#65">[65]</a>, а после ставшая частью некоторых моделей, например, PaLM-540B <a href="#66">[66]</a>, OpenAI GPT-o1 <a href="#67">[67]</a> и DeepSeek-R1 <a href="#68">[68]</a>).</p>
<p>Обучение модели GPT-3 на текстовых данных с диалогами и создание на его базе продукта с механизмом чата и промптами — ChatGPT — стало поворотным моментом в распространении БЯМ. Как считает мыслитель Джон Носта <a href="#69">[69]</a>, успех обусловлен работе продукта на «операционной системе человечества» — языке и его письменному воплощению — тексте. Модели хорошо показывают себя в работе с естественным языком, а как они показывают себя в задачах программирования — об этом будет рассказано в следующем разделе.</p>
<h2>2.2. Методы поиска неисправностей в программном обеспечении с использованием больших языковых моделей</h2>
<p>В этом разделе будут рассмотрены методы и инструменты для поиска неисправностей в ПО с использованием машинного обучения и больших языковых моделей. Некоторые из инструментов для поиска неисправностей можно отнести к статическому или динамическому анализу, однако упор инструментов на использование нейронных сетей и больших языковых моделей не позволяет ставить их в один ряд с классическими методами.</p>
<h3>2.2.1. Статический анализ с использованием больших языковых моделей</h3>
<p>Как уже было сказано, статический анализ — метод исследования программного кода без запуска программы. Метод работает с исходным кодом программы или его представлением — таким образом, в любом случае, работает с текстом. Данный метод выглядит хорошим кандидатом на получение выгоды от больших языковых моделей. Далее будет рассказано об инструментах, которые попытались получить эту выгоду.</p>
<p>SkipAnalyzer <a href="#70">[70]</a> — статический анализатор и средство исправления ошибок, использующий БЯМ во всех своих компонентах: в поиске ошибок, фильтре ложных срабатываний и генераторе исправлений. Инструмент выполнен только в виде исследовательской работы и представляет собой проверку гипотезы (англ. proof-of-concept) с использованием моделей ChatGPT. Создатели инструмента утверждают, что он показывает результаты лучше, чем статический анализатор Infer от Facebook, не использующий БЯМ.</p>
<p>IRIS <a href="#71">[71]</a> — инструмент, сочетающий в себе CodeQL, описанный ранее, и БЯМ <a href="#72">[72]</a>. В ходе своей работы IRIS собирает кандидаты для ошибок в коде самой программы и используемых библиотеках, используя CodeQL, маркирует входы и выходы данных, потенциально пригодные для исследуемой ошибки, используя БЯМ, анализирует граф вызовов для входов и выходов, снова используя CodeQL, фильтрует ложные срабатывания и показывает результат разработчику, используя БЯМ. Как заявляют авторы, ключевой идеей проекта была гипотеза, что «большие языковые модели видели достаточно использований различных библиотек и API и у них должно быть понимание о представленных там ошибках».</p>
<p>Semgrep <a href="#73">[73]</a> реализует поиск неисправностей и уязвимостей в исходном коде на основе правил, заданных пользователем-разработчиком. Бесплатная версия, работающая локально, позволяет искать ошибки внутри одного файла, в то время как платная версия позволяет отслеживать выполнение кода между файлами, даёт доступ к платформе для поиска неисправностей и доступ к цифровому ассистенту на основе БЯМ, понижающему число ложный срабатываний. Инструмент можно использовать как отдельную утилиту через  интерфейс командной строки (англ. CLI — command line interface), как часть процесса сборки, получая комментарии к изменениям — коммитам и запросам на изменения (англ. commits и Pull Requests).</p>
<p>DeepCode <a href="#74">[74]</a> — статический анализатор от Snyk, основанный на машинном обучении. Инструмент обучался на исходном коде проектов, выложенных на GitHub, используя AST для лучшего понимания конструкций языка. DeepCode AI лежит в основе целой платформы от Snyk, направленной на анализ ошибок и уязвимостей в программах.</p>
<p>Нетрудно заметить, что среди инструментов статического анализа крайне мало тех, которые полагаются на большие языковые модели полностью. Связано это, прежде всего, с природой языковых моделей: их основная задача — создание нового текста, а не тщательная обработка существующего. Известно также, что БЯМ склонны «галлюцинировать» — создавать правдоподобный, но не правдивый ответ <a href="#75">[75]</a>.</p>
<p>Большие языковые модели основаны на статистике и поэтому восприимчивы к данным, используемым для обучения. Несмотря на то, что современные большие языковые модели обучены на корпусах текста, которые содержат в себе большую часть интернета, качественного исходного кода там крайне мало — ещё меньше исходного кода, пригодного для обучения поиска неисправностей, так как нужен код с ошибкой и без неё.</p>
<p>Показательны исследования как обычных моделей, так и программных комплексов в задаче по поиску неисправностей <a href="#76">[76]</a><a href="#77">[77]</a><a href="#78">[78]</a><a href="#79">[79]</a>. Например, разработчики универсального статического анализатора PVS-Studio провели тестирование инструмента DeepCode от Sync на проекте PhysX <a href="#80">[80]</a> и пришли к выводу, что классические методы с тонко настроенными правилами нахождения ошибок показывают себя лучше инструментов с большими языковыми моделями. Авторы утверждают, что «обучение на коде будет ограничено этим самым кодом и, если что-то будет выбиваться из общего паттерна или проявляться лишь в редких случаях, ошибка или недочет смогут проскочить незамеченными», в то время как «для классического же статического анализа нет необходимости, чтобы ошибка встречалась много-много раз — достаточно, чтобы разработчик диагностики придумал общий принцип появления ошибки».</p>
<h3>2.2.2. Динамический анализ с использованием больших языковых моделей</h3>
<p>Динамический анализ в классическом виде, строго говоря, невыполним с использованием больших языковых моделей, так как анализ предполагает работу не с текстом — исходным кодом программы, — а с запущенной программой. Однако, БЯМ могут помочь в создании инструментов для классического динамического анализа — например, в генерации тестов различного уровня: юнит-тестов, интеграционных тестов <a href="#81">[81]</a><a href="#82">[82]</a><a href="#83">[83]</a><a href="#84">[84]</a>. Однако следует помнить о галлюцинациях моделей и оставлять последнее решение об имплементации проверок за разработчиками.</p>
<h2>2.3. Методы исправления неисправностей в программном обеспечении с использованием больших языковых моделей</h2>
<p>Ранее было сказано, что большие языковые модели плохо справляются с анализом кода, однако хорошо — с генерацией текста: исходного кода и его объяснением. Исправление неисправностей, по определению — создание или исправление существующего кода по определённым требованиям, что звучит подходящей задачей для языковых моделей.</p>
<p>Большие языковые модели в контексте инструментов автоматизированного исправления программ являются продолжением методов на основе машинного обучения. Представление архитектуры трансформеров и увеличение данных для обучения положительно сказались на способности инструментов создавать исправления, проходящие тесты. Однако, большие языковые модели общего назначения, например ChatGPT, показывают себя хуже специализированных средств для исправления программ <a href="#85">[85]</a>. Использование же более специализированных моделей, обученных на корпусах с упором на исходный код, например InCoder, Codex, DeepSeek-Coder-V2, позволяет достигать лучших результатов, чем у инструментов для исправления программ без использования машинного обучения <a href="#86">[86]</a><a href="#87">[87]</a><a href="#88">[88]</a><a href="#89">[89]</a>.</p>
<p>Кроме обособленных моделей на рынке также представлены инструменты для исправления программ. Например, DeepCode AI Fix — инструмент от Snyk, который был уже упомянут ранее, умеет не только искать ошибки, но и исправлять их <a href="#90">[90]</a>, Patchwork, который позволяет пошагово собирать исправления <a href="#91">[91]</a>, Style-Analyzer для исправления ошибок форматирования <a href="#92">[92]</a>, CodePatchLLM — фреймворк для БЯМ, получающий обратную связь от статического анализатора Svace <a href="#93">[93]</a>.</p>
<p>Как и в случае с классическими методами исправления программ, исправления инструментов на основе БЯМ должны быть в итоге проверены разработчиками-людьми. Особенно это важно, если принять во внимание галлюцинации моделей. И хотя современные инструменты для программирования предлагают проверку кода на основе языковых моделей (GitHub Copilot <a href="#94">[94]</a>, CodeRabbit <a href="#95">[95]</a>), решение о том, насколько представленные замечания валидны, существенны ли они в данном проекте, соответствуют ли исправления требованиям к программе — всё это до сих пор может быть оценено только непосредственным разработчиком решения.</p>
<h1>3.СОЗДАНИЕ ПРОГРАММНОГО ПРОТОТИПА ДЛЯ ПОИСКА И ИСПРАВЛЕНИЯ НЕИСПРАВНОСТЕЙ В ПРОГРАММНОМ ОБЕСПЕЧЕНИИ</h1>
<p>В этой главе будет рассказано о практической стороне работы — разработке программного прототипа для поиска и исправления неисправностей в программном обеспечении. Будет рассказано, что представляет из себя прототип, почему он именно такой, кем и как он может быть использован и какие результаты показывает при реальном использовании.</p>
<h2>3.1. Описание артефакта работы</h2>
<p>Артефактом данной работы является плагин для средства сборки Maven, который используется в Java проектах — bugfix-suggester-maven-plugin. Плагин предлагает исправления в исходном коде на основе ошибок, найденных другими плагинами — анализаторами кода, в частности, SpotBugs — одним из самых популярных анализаторов для языка Java. Для создания исправлений плагин использует сервер Ollama <a href="#96">[96]</a>, который позволяет запускать БЯМ на мощностях, контролируемых пользователем.</p>
<p>Паттерн плагина для средств сборки — основной паттерн для разработки инструментов для средств сборки Maven. Менеджер зависимостей, анализаторы кода, инструменты применения форматирования, упаковка приложения в дистрибутивы — всё это выполнено в виде плагинов <a href="#97">[97]</a>.</p>
<p>В качестве компонента для поиска ошибок был выбран плагин SpotBugs с расширением FindSecBugs, так как этот инструмент превосходит остальные подобные инструменты в ряде исследований <a href="#98">[98]</a><a href="#99">[99]</a>, а также просто и гибко настраивается, имеет удобный графический интерфейс для просмотра найденных ошибок, выводит ошибки в виде HTML-файла, совместимого с файлами, из которых состоит отчёт сборки Java-приложения.</p>
<p>Для генерации исправлений используется инструмент для запуска БЯМ локально — Ollama. Выбор в пользу больших языковых моделей был сделан аналогично решению авторов IRIS, о котором было рассказано выше: языковые модели «видели» достаточно правильного использования библиотек, чтобы предложить решения, достойные к рассмотрению конечным пользователем. Выбор же в пользу локального запуска моделей был сделан по двум причинам: позиционирование решения и в исследовательских целях.</p>
<p>Артефакт работы ориентирован на пользователей, которые разрабатывают программное обеспечение с закрытым исходным кодом и не могут допустить его утечки. К таким клиентам относятся компании-разработчики систем безопасности, банковский сектор, промышленные предприятия. Такие пользователи предпочитают иметь решения, работающие на своих мощностях со своими стандартами безопасности, и не могут допустить использования инструментов, которые прямо или косвенно отправляют данные вне контура компании.</p>
<p>Большинство поставщиков облачных сервисов с БЯМ заверяют, что не используют пользовательский ввод и вывод для обучения моделей, однако эти же поставщики уточняют, что могут использовать ввод и вывод для улучшения продукта, не раскрывая, в чём именно это выражается. Например, политика приватности OpenAI <a href="#100">[100]</a> утверждает, что может использовать пользовательские данные для тренировки моделей до тех пор, пока пользователь это разрешает. Политика приватности GitHub Copilot <a href="#101">[101]</a> заявляет, что не использует пользовательский ввод для обучения моделей на тарифных планах для Бизнесов и Корпораций, ничего не говоря про Бесплатный и Профессиональный планы.</p>
<p>С исследовательской точки зрения работа проверяет возможности современных больших языковых моделей с открытым исходным кодом и устанавливаемых локально для полноценного использования в качестве ассистентов по созданию исходного кода и исправлению ошибок. Работа является проверкой концепта, что современные архитектуры БЯМ не привязаны к мощностям облачных провайдеров.</p>
<h2>3.2. Использование артефакта работы</h2>
<p>Как уже было сказано, артефакт представляет собой плагин для средства сборки Maven и предполагает соответствующее использование. Плагин размещается в скрипте сборки проекта после плагинов, используемых для анализа кода и принимает их отчёты во входном параметре как источники ошибок, для которых нужно создать исправления. В качестве следующего параметра нужно указать модель, доступную на используемом сервере Ollama, которая будет использоваться для генерации исправлений, и промпт — подсказку для модели, каким ожидается исправление.</p>
<p>Пример использования плагина-анализатора и артефакта работы:</p>
<pre><code class="language-xml">&lt;reporting&gt;
    &lt;plugins&gt;
        &lt;!-- mvn com.github.spotbugs:spotbugs-maven-plugin:gui to show GUI --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;
            &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;4.8.5.0&lt;/version&gt;
            &lt;configuration&gt;
                &lt;effort&gt;Max&lt;/effort&gt;
                &lt;threshold&gt;low&lt;/threshold&gt;
                &lt;failOnError&gt;true&lt;/failOnError&gt;
                &lt;includeFilterFile&gt;${project.basedir}/spotbugs-include.xml&lt;/includeFilterFile&gt;
                &lt;excludeFilterFile&gt;${project.basedir}/spotbugs-exclude.xml&lt;/excludeFilterFile&gt;
                &lt;plugins&gt;
                    &lt;plugin&gt;
                        &lt;groupId&gt;com.h3xstream.findsecbugs&lt;/groupId&gt;
                        &lt;artifactId&gt;findsecbugs-plugin&lt;/artifactId&gt;
                        &lt;version&gt;1.13.0&lt;/version&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;!-- mvn com.salat:bugfix-suggester-maven-plugin:suggest --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.salat.bugfix-suggester&lt;/groupId&gt;
            &lt;artifactId&gt;bugfix-suggester-maven-plugin&lt;/artifactId&gt;
			&lt;configuration&gt;&lt;inputFileWithBugs&gt;${build.directory}/spotbugsXml.xml&lt;/inputFileWithBugs&gt;
                &lt;modelName&gt;deepseek-coder-v2:lite&lt;/modelName&gt;
                &lt;prompt&gt;SpotBugs after analysis gives this error. Suggest a fix. The error: %bugContent%. Source code: ```%sourceFile%```. Keep the answer small and precise, code mostly.&lt;/prompt&gt;
                &lt;modelRequestTimeout&gt;9000&lt;/modelRequestTimeout&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/reporting&gt;

</code></pre>
<p>Артефакт используется на стадии сборки site средства Maven. Во время этой стадии создаётся документация проекта, запускаются анализаторы кода, артефакт работы, затем файлы-отчёты всех инструментов собираются в сайт-отчёт и становятся доступны вместе с артефактом программы. Такой подход был выбран как продолжение работы SpotBugs: его основное использование это создание файлов-отчётов, поэтому инструмент для исправления ошибок должен работать таким же образом.</p>
<p>Также артефакт может запущен отдельно через интерфейс командной строки для использования в решениях, не поддерживающих отчёты.</p>
<h2>3.3. Влияние артефакта работы на процесс разработки программного обеспечения</h2>
<p>При разработке артефакта работы было стремление минимизировать усилия по настройке инструмента, чтобы уменьшить негативное влияние на процесс разработки программного обеспечения. Именно поэтому 1. артефакт выполнен в виде плагина для сборки, а не полноценного отдельного инструмента — всё, что требуется для использования, это добавление зависимости в проект программы; 2. артефакт выполнен в виде плагина при стадии создания отчёта — это вспомогательная стадия и не влияет на компиляцию проекта программы.</p>
<p>Основная сложность, которая остаётся на стороне пользователя — управление сервером Ollama, предоставляющему языковые модели. Частью этой сложности является управлением времени сборки: так как большие языковые модели склонны требовать большое количество ресурсов, а на большом проекте может быть найдено большое количество ошибок, требующих исправления, время создания отчётов и нагрузка на мощности, используемые при сборки, может существенно возрасти. Управление этой сложностью вынесено за рамки данной работы, так как предполагается, что у пользователя есть свои требования к установке этого сервера, и автор работы не может их учесть целиком. Со стороны артефакта предложены средства для оптимизации работы — для сокращения времени создания отчёта и снижения нагрузки на сервера, используемые при сборке: 1. возможность указания сетевого адреса сервера Ollama, если используется установка его на отдельную машину; 2. указание названия модели для генерации исправлений для использования более быстрых и оптимизированных моделей.</p>
<p>Распространенной практикой при разработке больших программ является концепция Непрерывная Интеграция и Непрерывная доставка (англ. CI/CD — Continuous Integration &amp; Continuous Delivery) <a href="#102">[102]</a>, частью которого является ежедневный запуск конвейеров сборки приложения. Частой реализаций этой практики является запуск сложных конвейеров сборки в нерабочие часы организации, тогда как в рабочее время при изменениях кода запускаются более простые конвейеры, чтобы разработчики получали результаты сборки, результаты своих экспериментов. Артефакт работы создавался с учётом именно этой практики, в том числе из-за тщательности и скорости работы языковых моделей.</p>
<h2>3.4. Применимость артефакта работы</h2>
<p>Несмотря на описанные выше сложности в виде увеличения времени и нагрузки на сервера для сборки проектов, стоит отметить его успешную применимость.</p>
<p>Работа артефакта проверялась на личном проекте автора briene (3182 строки кода), на проекте самого артефакта (1022 строки кода) и на проектах с открытым исходным кодом: JUnit4 как проект среднего размера (32 232 строки кода) и Debezium — большой многомодульный проект (249 803 строки кода). Тестирование проводилось на машине со следующими характеристиками: AMD Ryzen 7 7840H w/ Radeon(TM) 780M Graphics     3.80 GHz, 32 Гб ОЗУ. Конфигурация плагина для SpotBugs и артефакта представлены на фрагменте исходного кода ниже. Результаты тестирования представлены в таблице 1.</p>
<p>Конфигурация плагинов для испытания:</p>
<pre><code class="language-xml">&lt;!-- mvn com.github.spotbugs:spotbugs-maven-plugin:4.8.5.0:spotbugs --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;
    &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;4.8.5.0&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;default-cli&lt;/id&gt;
            &lt;configuration&gt;
                &lt;fork&gt;false&lt;/fork&gt;
                &lt;effort&gt;Max&lt;/effort&gt;
                &lt;threshold&gt;Low&lt;/threshold&gt;
                &lt;failOnError&gt;true&lt;/failOnError&gt;
                &lt;includeFilterFile&gt;${project.basedir}/spotbugs-include.xml&lt;/includeFilterFile&gt;
                &lt;excludeFilterFile&gt;${project.basedir}/spotbugs-exclude.xml&lt;/excludeFilterFile&gt;
                &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;
                &lt;plugins&gt;
                    &lt;plugin&gt;
                        &lt;groupId&gt;com.h3xstream.findsecbugs&lt;/groupId&gt;
                        &lt;artifactId&gt;findsecbugs-plugin&lt;/artifactId&gt;
                        &lt;version&gt;1.13.0&lt;/version&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
&lt;!-- mvn com.salat:bugfix-suggester-maven-plugin:suggest --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;com.salat.bugfix-suggester&lt;/groupId&gt;
    &lt;artifactId&gt;bugfix-suggester-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;default-cli&lt;/id&gt;
            &lt;configuration&gt;
                &lt;modelName&gt;deepseek-coder-v2:lite&lt;/modelName&gt;
                &lt;modelRequestTimeout&gt;9000&lt;/modelRequestTimeout&gt;
                &lt;prompt&gt;SpotBugs after analysis gives this error. Suggest a fix. The error: %bugContent%. Source code: ```%sourceFile%```. Keep the answer small and precise, code mostly.&lt;/prompt&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;

</code></pre>
<p>Таблица 1. Результаты испытания артефакта работы</p>
<table>
<thead>
<tr><th> Проект                        </th><th> Строк кода </th><th> Модель                 </th><th> Найдено ошибок (SpotBugs) </th><th> Предложено исправлений (bugfix-suggester) </th><th> Затраченное время  </th></tr>
</thead>
<tbody>
<tr><td> bugfix-suggester-maven-plugin </td><td> 1022       </td><td> deepseek-coder-v2:lite </td><td> 85                        </td><td> 85                                        </td><td> 32 минуты          </td></tr>
<tr><td> bugfix-suggester-maven-plugin </td><td> 1022       </td><td> codegemma              </td><td> 85                        </td><td> 85                                        </td><td> 54 минуты          </td></tr>
<tr><td> briene                        </td><td> 3182       </td><td> deepseek-coder-v2:lite </td><td> 56                        </td><td> 56                                        </td><td> 38 минут           </td></tr>
<tr><td> briene                        </td><td> 3182       </td><td> codegemma              </td><td> 56                        </td><td> 56                                        </td><td> 46 минут           </td></tr>
<tr><td> JUnit4                        </td><td> 32 232     </td><td> deepseek-coder-v2:lite </td><td> 123                       </td><td> 122                                       </td><td> 2 часа             </td></tr>
<tr><td> JUnit                         </td><td> 32 232     </td><td> codegemma              </td><td> 123                       </td><td> 122                                       </td><td> 2 часа 11 минут    </td></tr>
<tr><td> Debezium                      </td><td> 249 803    </td><td> deepseek-coder-v2:lite </td><td> 1216                      </td><td> 510                                       </td><td> 10 часов 30 минут* </td></tr>
</tbody>
</table>
<p>* Не удалось завершить испытание</p>
<p>По результатам тестирования видно, что артефакт сгенерировал исправления для большинства ошибок, которые были найдены инструментом SpotBugs, и для большинства проектов артефакт создал исправления меньше, чем за рабочий день (8 часов). Исключение — проект Debezium, в котором было найдено 1216 ошибок, а генерация исправлений только для половины из них заняла свыше 10 часов. Это является свидетельством того, что плагин для поиска неисправностей настроен на поиск всех возможных ошибок и не защищён от ложных срабатываний. Также на машине, которая выполняла генерацию исправлений, не использовалось аппаратное ускорение: время генерации исправления от больших языковых моделей можно сократить, используя GPU (graphics processing unit) от Nvidia с тензорными ядрами или NPU (neural processing unit) от разных производителей <a href="#103">[103]</a>.</p>
<h2>3.5. Преимущества артефакта работы</h2>
<p>Решение, предлагаемое в рамках данной работы, предлагает автоматизацию процессов обнаружения и исправления ошибок в программном обеспечении и направлено на улучшение следующих показателей: <ol> <li> Использование трудовых ресурсов. Как уже было сказано, инженеры в отделах НИОКР и инженеры поддержки часто сталкиваются с ошибками. Артефакт работы позволяет автоматизировать исправление ошибок и сосредоточить усилия инженеров на будущих разработках, которые позволят компании быстрее развиваться, проверять больше гипотез, реализовывать больше функций. <br><b>Метрика</b>: трудозатраты, время на обнаружение и исправление ошибок.</p>
</li>
<li>
Качество программного обеспечения. Исправление ошибок позволяет сделать программное обеспечение более надёжным и производительным, повысить уровень удовлетворённости продуктом конечным потребителем.
<br><b>Метрика</b> количество сбоев в ПО, показатели производительности, уровень удовлетворённости потребителей.
</li>
<li>
Экономические расходы. Артефакт работы использует существующие мощности компании и не требует дополнительных расходов на облачных провайдеров больших языковых моделей.
<br><b>Метрика</b>: экономические расходы на интеграции внешних сервисов.
</li>
<li>
Информационная безопасность. В зависимости от способа установки сервера Ollama артефакт производит все вычисления в подконтрольной компании среде: на машинах разработчиках, на собственных серверах компании-пользователя или на доверенных серверах партнёров. Компания-пользователь имеет детализированный контроль над потоком данных, который проходит через все компоненты артефакта за счёт использования компонентов с открытым исходным кодом.
<br><b>Метрика</b>: риски несанкционированного доступа к данным.
</li>
</ol>
<p>Среди имеющихся на момент написания работы подобных инструментов, артефакт работы занимает свою узкоспециализированную нишу. Сервисы для автоматизации поиска и исправления неисправностей в программном обеспечении либо очень ограниченно используют большие языковые модели (IRIS), либо полагаются на них во всем и работают с использованием облачных провайдеров (DeepCode, GitHub Copilot, Coderabbit). Отличается также и способ работы: сторонние инструменты работают при ручном запуске (IRIS, DeepCode), на этапе публикации изменений (GitHub Copilot, Coderabbit). Если рассматривать непосредственно большие языковые модели, установленные на мощностях компании, то, как уже было описано выше, они не справляются с анализом исходного кода на предмет ошибок. Артефакт работы же использует большие языковые модели при генерации исправлений, не зависит от облачных решений, применяется на этапе сборки проекта, а для поиска исправлений использует статический анализатор.</p>
<h1>ЗАКЛЮЧЕНИЕ</h1>
<p>В ходе данной работы были проанализированы средства поиска неисправностей с использованием статического и динамического анализа, изучены инструменты исправления неисправностей, было рассмотрено применение больших языковых моделей в соответствующих задачах. Был исследовал подход для поиска неисправностей с использованием статического анализатора и исправления неисправностей с использованием больших языковых моделей. По итогам анализа было получено, что лучше всего с поиском неисправностей справляются классические методы — статический и динамический анализы, а с исправлением — инструменты на основе больших языковых моделей.</p>
<p>Практическим результатом работы стало расширение для средства сборки программного обеспечения, использующее большие языковые модели как основу для предложения исправлений неисправностей. В ходе испытаний артефакта была доказана его применимость и польза в процессах поиска и исправления неисправностей, был получен эффект ускорения процесса работы с ошибками в программном обеспечении — с исправлением неисправностей артефакт работы справляется меньше, чем за рабочий день. В рамках работы в расширении реализована вся запланированная функциональность.</p>
<p>Говоря о дальнейшем векторе исследованией, можно выделить обработку ложных срабатываний с использованием отдельного обращения к большим языковым моделям и использование необходимого аппаратного ускорения для уменьшения времени ожидания ответа от сервера с большими языковыми моделями.</p>
<h1>СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ</h1>
<ol>
<li id="1">Development Support | Red Hat Customer Portal [Электронный ресурс] //Access.redhat.com. — 2025. Режим доступа: https://access.redhat.com/support/offerings/developer. — Загл. с экрана</li>
<li id="2">Rival X., Yi K. Introduction to static analysis: an abstract interpretation perspective. — Mit Press, 2020.</li>
<li id="3">Johnson S. C. Lint, a C program checker. — Murray Hill : Bell Telephone Laboratories, 1977.</li>
<li id="4">Find and fix problems in your JavaScript code - ESLint - Pluggable JavaScript Linter [Электронный ресурс] //Eslint.org. — 2025. Режим доступа: https://eslint.org. — Загл. с экрана</li>
<li id="5">Pylint - code analysis for Python | www.pylint.org [Электронный ресурс] //Pylint.org. — 2025. Режим доступа: https://www.pylint.org. — Загл. с экрана</li>
<li id="6">Clang-Tidy — Extra Clang Tools 21.0.0git documentation [Электронный ресурс] //Clang.llvm.org. — 2025. Режим доступа: https://clang.llvm.org/extra/clang-tidy. — Загл. с экрана</li>
<li id="7">PMD [Электронный ресурс] //Pmd.github.io. — 2025. Режим доступа: https://pmd.github.io. — Загл. с экрана</li>
<li id="8">SpotBugs [Электронный ресурс] //Spotbugs.github.io. — 2025. Режим доступа: https://spotbugs.github.io. — Загл. с экрана</li>
<li id="9">PVS‑Studio — решение для улучшения качества, защищенности (SAST) и безопасности кода [Электронный ресурс] //Pvs-studio.ru. — 2025. Режим доступа: https://pvs-studio.ru. — Загл. с экрана</li>
<li id="10">Better Code & Better Software | Ultimate Security and Quality | Sonar [Электронный ресурс] //Www.sonarsource.com. — 2025. Режим доступа: https://www.sonarsource.com. — Загл. с экрана</li>
<li id="11">Infer Static Analyzer | Infer | Infer [Электронный ресурс] //Fbinfer.com. — 2025. Режим доступа: https://fbinfer.com. — Загл. с экрана</li>
<li id="12">Distefano D. et al. Scaling static analyses at Facebook //Communications of the ACM. — 2019. — Т. 62. — №. 8. — С. 62-70.</li>
<li id="13">CodeQL [Электронный ресурс] //Codeql.github.com. — 2025. Режим доступа: https://codeql.github.com. — Загл. с экрана</li>
<li id="14">Avgustinov P. et al. QL: Object-oriented queries on relational data //30th European Conference on Object-Oriented Programming (ECOOP 2016). — Schloss Dagstuhl—Leibniz-Zentrum für Informatik, 2016. — С. 2: 1-2: 25.</li>
<li id="15">Huang J. C. An approach to program testing //ACM Computing Surveys (CSUR). — 1975. — Т. 7. — №. 3. — С. 113-128.</li>
<li id="16">Fuzz Testing of Application Reliability [Электронный ресурс] //Pages.cs.wisc.edu. — 2025. Режим доступа: https://pages.cs.wisc.edu/~bart/fuzz/fuzz.html — Загл. с экрана</li>
<li id="17">Luke, I am your fuzzer. Автоматизируем поиск уязвимостей в программах — Хакер [Электронный ресурс] //Xakep.ru. — 2025. Режим доступа: https://xakep.ru/2019/05/23/fuzzer. — Загл. с экрана</li>
<li id="18">JUnit — About [Электронный ресурс] //Junit.org. — 2025. Режим доступа: https://junit.org/junit4/ — Загл. с экрана</li>
<li id="19">GoogleTest User’s Guide | GoogleTest [Электронный ресурс] //Google.github.io. — 2025. Режим доступа: https://google.github.io/googletest. — Загл. с экрана</li>
<li id="20">pytest documentation [Электронный ресурс] //Docs.pytest.org. — 2025. Режим доступа: https://docs.pytest.org/en/stable. — Загл. с экрана</li>
<li id="21">JBroFuzz download | SourceForge.net [Электронный ресурс] //Sourceforge.net. — 2025. Режим доступа: https://sourceforge.net/projects/jbrofuzz. — Загл. с экрана</li>
<li id="22">Apache JMeter - Apache JMeter™ [Электронный ресурс] //Jmeter.apache.org. — 2025. Режим доступа: https://jmeter.apache.org. — Загл. с экрана</li>
<li id="23">Indrianto I. Performance testing on web information system using apache jmeter and blazemeter //Jurnal Ilmiah Ilmu Terapan Universitas Jambi. — 2023. — Т. 7. — №. 2. — С. 138-149.</li>
<li id="24">VisualVM: Home [Электронный ресурс] //Visualvm.github.io. — 2025. Режим доступа: https://visualvm.github.io/index.html — Загл. с экрана</li>
<li id="25">Kessler S. L. G. P. B., McKusick M. K. gprof: a Call Graph Execution Profiler1 //Proceedings of the Symposium on Compiler Construction, pp.—. Press, New York,,. Cited on p.. Greco, Gianluigi. — 1982.</li>
<li id="26">perf: Linux profiling with performance counters [Электронный ресурс] //Perfwiki.github.io. — 2025. Режим доступа: https://perfwiki.github.io/main. — Загл. с экрана</li>
<li id="27">Valgrind: Tool Suite [Электронный ресурс] //Valgrind.org. — 2025. Режим доступа: https://valgrind.org/info/tools.html. — Загл. с экрана</li>
<li id="28">GitHub - intuit/judo: Judo is an easy-to-use Command Line Interface (CLI) Integration Testing Framework, driven from a simple yaml file that also contains assertions. [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/intuit/judo. — Загл. с экрана</li>
<li id="29">Automated Testing. Understanding, designing, and setting up an effective automated testing strategy [Электронный ресурс] //Voyager.postman.com. — 2025. Режим доступа: https://voyager.postman.com/doc/automated-testing-whitepaper-postman.pdf. — Загл. с экрана</li>
<li id="30">Selenium [Электронный ресурс] //Www.selenium.dev. — 2025. Режим доступа: https://www.selenium.dev. — Загл. с экрана</li>
<li id="31">Puppeteer | Puppeteer [Электронный ресурс] //Pptr.dev. — 2025. Режим доступа: https://pptr.dev. — Загл. с экрана</li>
<li id="32">program-repair.org [Электронный ресурс] //Program-repair.org. — 2025. Режим доступа: https://program-repair.org. — Загл. с экрана</li>
<li id="33">Gazzola L., Micucci D., Mariani L. Automatic software repair: A survey //Proceedings of the 40th International Conference on Software Engineering. — 2018. — С. 1219-1219.</li>
<li id="34">Liu K. et al. On the efficiency of test suite based program repair: A systematic assessment of 16 automated repair systems for java programs //Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering. — 2020. — С. 615-627.</li>
<li id="35">GenProg [Электронный ресурс] //Squareslab.github.io. — 2025. Режим доступа: https://squareslab.github.io/genprog-code. — Загл. с экрана</li>
<li id="36">Weimer W. et al. Automatically finding patches using genetic programming //2009 IEEE 31st International Conference on Software Engineering. — IEEE, 2009. — С. 364-374.</li>
<li id="37">GitHub - SpoonLabs/astor: Automatic program repair for Java with generate-and-validate techniques :v::v:: jGenProg (2014) - jMutRepair (2016) - jKali  (2016) - DeepRepair (2017) - Cardumen (2018) - 3sfix (2018) [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/SpoonLabs/astor. — Загл. с экрана</li>
<li id="38">Responsive Nav · Advanced Left Navigation Demo [Электронный ресурс] //Qiyuhua.github.io. — 2025. Режим доступа: https://qiyuhua.github.io/projects/rsrepair. — Загл. с экрана</li>
<li id="39">Qi Y. et al. The strength of random search on automated program repair //Proceedings of the 36th international conference on software engineering. — 2014. — С. 254-265.</li>
<li id="40">GitHub - yyxhdy/arja: Multi-Objective GP for Automated Repair of Java [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/yyxhdy/arja. — Загл. с экрана</li>
<li id="41">Yuan Y., Banzhaf W. Arja: Automated repair of java programs via multi-objective genetic programming //IEEE Transactions on software engineering. — 2018. — Т. 46. — №. 10. — С. 1040-1067.</li>
<li id="42">GitHub - QIANZECHANG/SemFix: SemFix: Program Repair via Semantic Analysis [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/QIANZECHANG/SemFix. — Загл. с экрана</li>
<li id="43">Nguyen H. D. T. et al. Semfix: Program repair via semantic analysis //2013 35th International Conference on Software Engineering (ICSE). — IEEE, 2013. — С. 772-781.</li>
<li id="44">GitHub - SpoonLabs/nopol: Automatic program repair system for Java based on dynamic analysis and code synthesis with SMT. Also contains the code of Dynamoth. [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/SpoonLabs/nopol. — Загл. с экрана</li>
<li id="45">Xuan J. et al. Nopol: Automatic repair of conditional statement bugs in java programs //IEEE Transactions on Software Engineering. — 2016. — Т. 43. — №. 1. — С. 34-55.</li>
<li id="46">Pattern-based Automatic program Repair (PAR) [Электронный ресурс] //Sites.google.com. — 2025. Режим доступа: https://sites.google.com/site/autofixhkust. — Загл. с экрана</li>
<li id="47">Kim D. et al. Automatic patch generation learned from human-written patches //2013 35th international conference on software engineering (ICSE). — IEEE, 2013. — С. 802-811.</li>
<li id="48">Monperrus M. A critical review of" automatic patch generation learned from human-written patches": Essay on the problem statement and the evaluation of automatic software repair //Proceedings of the 36th International Conference on Software Engineering. — 2014. — С. 234-242.</li>
<li id="49">GitHub - TruX-DTF/AVATAR: AVATAR: Fixing Semantic Bugs with Fix Patterns of Static Analysis Violations [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/TruX-DTF/AVATAR. — Загл. с экрана</li>
<li id="50">Liu K. et al. Avatar: Fixing semantic bugs with fix patterns of static analysis violations //2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER). — IEEE, 2019. — С. 1-12.</li>
<li id="51">GitHub - TruX-DTF/fixminer_source: Mining Relevant Fix Patterns for Automated Program Repair [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/TruX-DTF/fixminer_source. — Загл. с экрана</li>
<li id="52">Koyuncu A. et al. Fixminer: Mining relevant fix patterns for automated program repair //Empirical Software Engineering. — 2020. — Т. 25. — С. 1980-2024.</li>
<li id="53">Chen L. et al. Program repair with repeated learning //IEEE Transactions on Software Engineering. — 2022. — Т. 49. — №. 2. — С. 831-848.</li>
<li id="54">Bhatia S., Kohli P., Singh R. Neuro-symbolic program corrector for introductory programming assignments //Proceedings of the 40th international conference on software engineering. — 2018. — С. 60-70.</li>
<li id="55">Kechagia M. et al. Evaluating automatic program repair capabilities to repair API misuses //IEEE Transactions on Software Engineering. — 2021. — Т. 48. — №. 7. — С. 2658-2679.</li>
<li id="56">Dikici S., Bilgin T. T. Advancements in automated program repair: a comprehensive review //Knowledge and Information Systems. — 2025. — С. 1-47.</li>
<li id="57">Qi Z. et al. An analysis of patch plausibility and correctness for generate-and-validate patch generation systems //Proceedings of the 2015 international symposium on software testing and analysis. — 2015. — С. 24-36.</li>
<li id="58">Ye H. et al. A comprehensive study of automatic program repair on the QuixBugs benchmark //Journal of Systems and Software. — 2021. — Т. 171. — С. 110825.</li>
<li id="59">Song F., Croft W. B. A general language model for information retrieval //Proceedings of the eighth international conference on Information and knowledge management. — 1999. — С. 316-321.</li>
<li id="60">Naveed H. et al. A comprehensive overview of large language models //arXiv preprint arXiv:2307.06435. — 2023.</li>
<li id="61">Vaswani A. et al. Attention is all you need //Advances in neural information processing systems. — 2017. — Т. 30.</li>
<li id="62">Radford A. et al. Improving language understanding by generative pre-training. — 2018.</li>
<li id="63">Radford A. et al. Language models are unsupervised multitask learners //OpenAI blog. — 2019. — Т. 1. — №. 8. — С. 9.</li>
<li id="64">Brown T. et al. Language models are few-shot learners //Advances in neural information processing systems. — 2020. — Т. 33. — С. 1877-1901.</li>
<li id="65">Qiao S. et al. Reasoning with language model prompting: A survey //arXiv preprint arXiv:2212.09597. — 2022.</li>
<li id="66">Narang S., Chowdhery A. Pathways language model (palm): Scaling to 540 billion parameters for breakthrough performance //Google AI Blog. — 2022.</li>
<li id="67">Learning to reason with LLMs | OpenAI [Электронный ресурс] //Openai.com. — 2024. Режим доступа: https://openai.com/index/learning-to-reason-with-llms. — Загл. с экрана</li>
<li id="68">Guo D. et al. Deepseek-r1: Incentivizing reasoning capability in llms via reinforcement learning //arXiv preprint arXiv:2501.12948. — 2025.</li>
<li id="69">Language: The Operating System Of Humanity And GPT | by JOHN NOSTA | Medium [Электронный ресурс] //Johnnosta.medium.com. — 2023. Режим доступа: https://johnnosta.medium.com/language-the-operating-system-of-humanity-and-gpt-4876cf0ed96a. — Загл. с экрана</li>
<li id="70">Mohajer M. M. et al. Skipanalyzer: A tool for static code analysis with large language models //arXiv preprint arXiv:2310.18532. — 2023.</li>
<li id="71">GitHub - iris-sast/iris: A neurosymbolic framework for vulnerability detection in code [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/iris-sast/iris. — Загл. с экрана</li>
<li id="72">Li Z., Dutta S., Naik M. IRIS: LLM-assisted static analysis for detecting security vulnerabilities //The Thirteenth International Conference on Learning Representations. — 2025.</li>
<li id="73">Semgrep App Security Platform | AI-assisted SAST, SCA and Secrets Detection [Электронный ресурс] //Semgrep.dev. — 2025. Режим доступа: https://semgrep.dev/index.html. — Загл. с экрана</li>
<li id="74">DeepCode AI | AI Code Review | AI Security for SAST | Snyk AI | Snyk [Электронный ресурс] //Snyk.io. — 2025. Режим доступа: https://snyk.io/platform/deepcode-ai. — Загл. с экрана</li>
<li id="75">Huang L. et al. A survey on hallucination in large language models: Principles, taxonomy, challenges, and open questions //ACM Transactions on Information Systems. — 2025. — Т. 43. — №. 2. — С. 1-55.</li>
<li id="76">Can open-source LLMs detect bugs in C++ code? :: Catid's Hacks [Электронный ресурс] //Catid.io. — 2023. Режим доступа: https://catid.io/posts/llm_bugs. — Загл. с экрана</li>
<li id="77">Chan A. et al. Transformer-based vulnerability detection in code at EditTime: Zero-shot, few-shot, or fine-tuning? //arXiv preprint arXiv:2306.01754. — 2023.</li>
<li id="78">Steenhoek B. et al. A comprehensive study of the capabilities of large language models for vulnerability detection //CoRR. — 2024.</li>
<li id="79">Khare A. et al. Understanding the effectiveness of large language models in detecting security vulnerabilities //2025 IEEE Conference on Software Testing, Verification and Validation (ICST). — IEEE, 2025. — С. 103-114.</li>
<li id="80">DeepCode: взгляд со стороны / Хабр [Электронный ресурс] //Habr.com. — 2029. Режим доступа: https://habr.com/ru/companies/pvs-studio/articles/496536. — Загл. с экрана</li>
<li id="81">Yang L. et al. An empirical study of unit test generation with large language models //arXiv preprint arXiv:2406.18181. — 2024.</li>
<li id="82">Pan R. et al. Multi-language unit test generation using llms //arXiv preprint arXiv:2409.03093. — 2024.</li>
<li id="83">Тимофеев, А. Н. Подход к повышению качества генерации программного кода большими языковыми моделями / А. Н. Тимофеев // Инновационные технологии обучения в вузе в условиях цифровизации и реформирования высшего образования : Материалы Всероссийской научно-методической конференции с международным участием, Улан-Удэ, 14—16 февраля 2024 года. — Улан-Удэ: ФГБОУ ВПО Восточно-Сибирский государственный университет технологий и управления, 2024. — С. 226-232. — EDN IJDAEB.</li>
<li id="84">Ишанхонов А. Ю. и др. Роль больших языковых моделей в интегрированных средах разработки нового поколения //Программные системы и вычислительные методы. — 2024. — №. 4. — С. 140-150.</li>
<li id="85">Sobania D. et al. An analysis of the automatic bug fixing performance of chatgpt //2023 IEEE/ACM International Workshop on Automated Program Repair (APR). — IEEE, 2023. — С. 23-30.</li>
<li id="86">Xia C. S., Wei Y., Zhang L. Automated program repair in the era of large pre-trained language models //2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE). — IEEE, 2023. — С. 1482-1494.</li>
<li id="87">Chen M. et al. Evaluating large language models trained on code //arXiv preprint arXiv:2107.03374. — 2021.</li>
<li id="88">Zhu Q. et al. Deepseek-coder-v2: Breaking the barrier of closed-source models in code intelligence //arXiv preprint arXiv:2406.11931. — 2024.</li>
<li id="89">Code editing leaderboard | aider [Электронный ресурс] //Aider.chat. — 2025. Режим доступа: https://aider.chat/docs/leaderboards/edit.html. — Загл. с экрана</li>
<li id="90">Berabi B. et al. Deepcode AI fix: Fixing security vulnerabilities with large language models //arXiv preprint arXiv:2402.13291. — 2024.</li>
<li id="91">GitHub - patched-codes/patchwork: Agentic AI framework for enterprise workflow automation. [Электронный ресурс] //Github.com. — 2025. Режим доступа: https://github.com/patched-codes/patchwork. — Загл. с экрана</li>
<li id="92">Markovtsev V. et al. STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms //2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR). — IEEE, 2019. — С. 468-478.</li>
<li id="93">Shaikhelislamov D., Drobyshevskiy M., Belevantsev A. CodePatchLLM: Configuring code generation using a static analyzer. — 2024.</li>
<li id="94">Using GitHub Copilot code review - GitHub Docs [Электронный ресурс] //Docs.github.com. — 2025. Режим доступа: https://docs.github.com/en/copilot/using-github-copilot/code-review/using-copilot-code-review. — Загл. с экрана</li>
<li id="95">AI Code Reviews | CodeRabbit | Try for Free [Электронный ресурс] //Www.coderabbit.ai. — 2025. Режим доступа: https://www.coderabbit.ai. — Загл. с экрана</li>
<li id="96">Ollama [Электронный ресурс] //Ollama.com. — 2025. Режим доступа: https://ollama.com. — Загл. с экрана</li>
<li id="97">Zwimpfer M. Investigating Plugin Usage in Open Source Maven Projects. — 2019.</li>
<li id="98">Li J., Yang J. Tracking the Evolution of Static Code Warnings: The State-of-the-Art and a Better Approach //IEEE Transactions on Software Engineering. — 2024. — Т. 50. — №. 3. — С. 534-550.</li>
<li id="99">Tomassi D. A. FSE: U: Bugs in the Wild: Examining the Effectiveness of Static Analyzers at Finding Real-World Bugs.</li>
<li id="100">How your data is used to improve model performance | OpenAI Help Center [Электронный ресурс] //OpenAI. — 2025. Режим доступа: https://help.openai.com/en/articles/5722486-how-your-data-is-used-to-improve-model-performance. — Загл. с экрана</li>
<li id="101">Trust Center [Электронный ресурс] //Copilot.github.trust.page. — 2025. Режим доступа: https://copilot.github.trust.page/faq?s=v2qe7voltpwtv2usl4ikhs. — Загл. с экрана</li>
<li id="102">Zampetti F. et al. CI/CD pipelines evolution and restructuring: A qualitative and quantitative study //2021 IEEE International Conference on Software Maintenance and Evolution (ICSME). — IEEE, 2021. — С. 471-482.</li>
<li id="103">The Best GPUs for Deep Learning in 2023 — An In-depth Analysis [Электронный ресурс] //Timdettmers.com. — 2025. Режим доступа: https://timdettmers.com/2023/01/30/which-gpu-for-deep-learning. — Загл. с экрана</li>
</ol>
<h1>ПРИЛОЖЕНИЯ</h1>
<ol>
<li>Исходный код плагина для исправления ошибок на основе БЯМ: <a href="https://github.com/TomSuworof/bugfix-suggester-maven-plugin">https://github.com/TomSuworof/bugfix-suggester-maven-plugin</a>.</li>
</ol>
    </div>
</body>
</html>